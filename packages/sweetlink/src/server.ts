import { WebSocketServer, WebSocket } from 'ws';
import { createServer, type IncomingMessage, type ServerResponse } from 'http';
import { promises as fs } from 'fs';
import { join } from 'path';
import Anthropic from '@anthropic-ai/sdk';

// Package info for HTTP responses
const PACKAGE_INFO = {
  name: '@ytspar/sweetlink',
  version: '1.0.0',
  description: 'Autonomous development toolkit for AI agents - screenshots, DOM queries, console logs, and JavaScript execution via WebSocket and Chrome DevTools Protocol',
  documentation: 'https://github.com/ytspar/devtools/tree/main/packages/sweetlink',
  protocol: 'WebSocket',
  note: 'This is a WebSocket server. Connect using a WebSocket client (ws://localhost:<port>) instead of HTTP.',
};

// Import shared types
import type {
  SweetlinkCommand,
  SweetlinkResponse,
  ConsoleLog,
  HmrScreenshotData,
  LogSubscription,
  ChannelSubscription
} from './types.js';

// Import shared utilities
import {
  generateSlugFromUrl,
  generateBaseFilename,
  truncateMessage,
  SCREENSHOT_DIR,
  HMR_SCREENSHOT_DIR,
  MAX_LOG_MESSAGE_LENGTH
} from './urlUtils.js';

// Re-export types for backwards compatibility
export type { SweetlinkCommand, SweetlinkResponse, ConsoleLog, HmrScreenshotData };

// ============================================================================
// Constants
// ============================================================================

/** Timeouts */
const SCREENSHOT_REQUEST_TIMEOUT_MS = 10000;

/** Claude API settings */
const CLAUDE_MODEL = 'claude-opus-4-5-20251101';
const CLAUDE_MAX_TOKENS = 2048;

/** Claude Opus 4.5 pricing (per million tokens) */
const CLAUDE_PRICING = {
  input: 15,
  output: 75,
} as const;

// Internal subscription tracking interfaces (include WebSocket reference)
interface InternalLogSubscription extends LogSubscription {
  clientWs: WebSocket;
}

interface InternalChannelSubscription extends ChannelSubscription {
  clientWs: WebSocket;
}

// Pending screenshot requests
interface PendingScreenshotRequest {
  requestId: string;
  clientWs: WebSocket;
  timeout: NodeJS.Timeout;
}

/** Design review prompt for Claude Vision */
const DESIGN_REVIEW_PROMPT = `You are an expert UI/UX designer and frontend developer reviewing a web application screenshot.

Analyze this screenshot and provide a structured design review. Be specific, actionable, and prioritize the most impactful issues.

## Review Categories

### 1. Visual Bugs & Broken Elements
- Elements that appear cut off, overlapping incorrectly, or misaligned
- Broken layouts or obvious rendering issues
- Missing images or icons
- Text overflow or truncation problems

### 2. Design Inconsistencies
- Inconsistent spacing (margins, padding, gaps)
- Mismatched colors that break the visual hierarchy
- Typography inconsistencies (font sizes, weights, line heights)
- Border radius or shadow inconsistencies

### 3. Accessibility Concerns
- Low contrast text that may be hard to read
- Interactive elements that appear too small
- Missing visual focus indicators
- Color-only information conveyance

### 4. UI/UX Issues
- Confusing visual hierarchy
- Poor information density (too crowded or too sparse)
- Unclear interactive elements
- Navigation or wayfinding problems

### 5. Responsive Design Concerns
- Elements that may not scale well
- Fixed widths that could cause issues
- Content that may overflow on smaller screens

## Response Format

Provide your review in this markdown format:

# Design Review

## Summary
[1-2 sentence overview of the design quality and main concerns]

## Critical Issues
- [ ] [Issue description with specific location and fix recommendation]

## Improvements
- [ ] [Improvement suggestion with rationale]

## Positive Observations
- [What's working well in this design]

---
*Review generated by Sweetlink Design Review*

Be concise but specific. Reference element locations (e.g., "the header nav", "bottom-right card", "search input in toolbar").
If the screenshot shows a well-designed interface with no major issues, say so clearly.`;

// Lazy-loaded Anthropic client
let anthropicClient: Anthropic | null = null;

function getAnthropicClient(): Anthropic {
  if (!anthropicClient) {
    anthropicClient = new Anthropic();
  }
  return anthropicClient;
}

let wss: WebSocketServer | null = null;
let activePort: number | null = null;
let associatedAppPort: number | null = null;
const clients = new Map<WebSocket, { type: 'browser' | 'cli'; id: string; origin?: string }>();

// v1.4.0: Subscription tracking
const logSubscriptions = new Map<string, InternalLogSubscription>();
const channelSubscriptions = new Map<string, InternalChannelSubscription[]>();
const pendingScreenshotRequests = new Map<string, PendingScreenshotRequest>();

// HMR screenshot sequence counter
let hmrSequenceNumber = 0;

export interface InitSweetlinkOptions {
  port: number;
  /** Number of alternative ports to try if the primary port is in use (default: 10) */
  maxPortRetries?: number;
  /** Called when server starts successfully with the actual port */
  onReady?: (port: number) => void;
  /** The port of the associated dev server (e.g., Next.js port). Used to validate browser connections. */
  appPort?: number;
}

/**
 * Initialize Sweetlink WebSocket server
 * Automatically tries alternative ports if the specified port is in use
 */
export function initSweetlink(options: InitSweetlinkOptions): Promise<WebSocketServer> {
  return new Promise((resolve, reject) => {
    if (wss) {
      console.warn('[Sweetlink] Server already initialized on port', activePort);
      resolve(wss);
      return;
    }

    const maxRetries = options.maxPortRetries ?? 10;
    let currentPort = options.port;
    let attempts = 0;

    // Store the associated app port for origin validation
    associatedAppPort = options.appPort ?? null;
    if (associatedAppPort) {
      console.log(`[Sweetlink] Associated with app on port ${associatedAppPort}`);
    }

    const tryPort = (port: number) => {
      attempts++;

      // Create HTTP server to handle direct HTTP requests with package info
      const httpServer = createServer((_req: IncomingMessage, res: ServerResponse) => {
        // Return package info for direct HTTP requests (not WebSocket upgrades)
        res.writeHead(200, {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        });
        res.end(JSON.stringify({
          ...PACKAGE_INFO,
          status: 'running',
          port: port,
          appPort: associatedAppPort,
          connectedClients: clients.size,
          uptime: process.uptime(),
        }, null, 2));
      });

      httpServer.on('error', (error: NodeJS.ErrnoException) => {
        if (error.code === 'EADDRINUSE') {
          httpServer.close();
          if (attempts < maxRetries) {
            const nextPort = port + 1;
            console.log(`[Sweetlink] Port ${port} in use, trying ${nextPort}...`);
            tryPort(nextPort);
          } else {
            const errMsg = `[Sweetlink] Could not find available port after ${maxRetries} attempts (tried ${options.port}-${port})`;
            console.error(errMsg);
            reject(new Error(errMsg));
          }
        } else {
          console.error('[Sweetlink] Server error:', error);
          reject(error);
        }
      });

      httpServer.listen(port, () => {
        // Create WebSocket server on top of HTTP server
        const server = new WebSocketServer({ server: httpServer });

        // Server started successfully
        wss = server;
        activePort = port;
        console.log(`[Sweetlink] WebSocket server started on ws://localhost:${port}`);
        console.log(`[Sweetlink] HTTP info available at http://localhost:${port}`);
        if (port !== options.port) {
          console.log(`[Sweetlink] Note: Using alternative port (original ${options.port} was in use)`);
        }
        options.onReady?.(port);
        setupServerHandlers(server);
        resolve(server);
      });
    };

    tryPort(currentPort);
  });
}

/** Get the port the server is running on */
export function getSweetlinkPort(): number | null {
  return activePort;
}

/** Get the associated app port */
export function getAssociatedAppPort(): number | null {
  return associatedAppPort;
}

function setupServerHandlers(server: WebSocketServer) {
  server.on('connection', (ws: WebSocket, req: IncomingMessage) => {
    const clientId = `${req.socket.remoteAddress}:${req.socket.remotePort}`;
    const origin = req.headers.origin;

    // Validate origin - accept any localhost connection in dev mode
    // This allows connections from any port (e.g., when Vite picks a different port)
    // and from stale browser tabs on old ports
    if (origin) {
      const isLocalhost = origin.startsWith('http://localhost:') ||
                          origin.startsWith('http://127.0.0.1:');

      if (!isLocalhost) {
        console.log(`[Sweetlink] Rejecting non-localhost connection from ${origin}`);
        ws.close(4001, 'Only localhost connections allowed');
        return;
      }

      // Log if connection is from a different port than expected (informational only)
      if (associatedAppPort) {
        const expectedOrigins = [
          `http://localhost:${associatedAppPort}`,
          `http://127.0.0.1:${associatedAppPort}`,
        ];
        if (!expectedOrigins.some(expected => origin.startsWith(expected))) {
          console.log(`[Sweetlink] Accepting connection from ${origin} (configured port: ${associatedAppPort})`);
        }
      }
    }

    // Initially mark as CLI client, will be updated if browser identifies itself
    clients.set(ws, { type: 'cli', id: clientId, origin: origin || undefined });

    console.log(`[Sweetlink] Client connected: ${clientId}${origin ? ` from ${origin}` : ''}`);

    ws.on('message', async (message: Buffer) => {
      try {
        const command = JSON.parse(message.toString()) as SweetlinkCommand;

        // Skip logging for response messages (no type field = response from browser)
        if (command.type) {
          console.log('[Sweetlink] Received message type:', command.type);
        }

        // Handle browser client identification
        if (command.type === 'browser-client-ready') {
          const clientInfo = clients.get(ws);
          clients.set(ws, { type: 'browser', id: clientId, origin: clientInfo?.origin });
          console.log(`[Sweetlink] Browser client identified: ${clientId}`);

          // Send server info back to the browser so it can verify connection
          ws.send(JSON.stringify({
            type: 'server-info',
            appPort: associatedAppPort,
            wsPort: activePort,
            projectDir: process.cwd(),
            timestamp: Date.now()
          }));
          return;
        }

        // Handle screenshot save request from browser
        if (command.type === 'save-screenshot') {
          console.log('[Sweetlink] Received save-screenshot command, hasData:', !!command.data);
          const clientInfo = clients.get(ws);
          console.log('[Sweetlink] Client info:', clientInfo);

          if (command.data && clientInfo?.type === 'browser') {
            const savedPath = await handleSaveScreenshot(command.data);
            console.log(`[Sweetlink] Screenshot saved to ${savedPath}`);

            // Send confirmation back to browser
            ws.send(JSON.stringify({
              success: true,
              type: 'screenshot-saved',
              path: savedPath,
              timestamp: Date.now()
            }));
            return;
          }
        }

        // Handle design review screenshot request from browser
        if (command.type === 'design-review-screenshot') {
          console.log('[Sweetlink] Received design-review-screenshot command');
          const clientInfo = clients.get(ws);

          if (command.data && clientInfo?.type === 'browser') {
            try {
              const result = await handleDesignReviewScreenshot(command.data);
              console.log(`[Sweetlink] Design review saved to ${result.reviewPath}`);

              // Send confirmation back to browser
              ws.send(JSON.stringify({
                success: true,
                type: 'design-review-saved',
                screenshotPath: result.screenshotPath,
                reviewPath: result.reviewPath,
                timestamp: Date.now()
              }));
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Unknown error';
              console.error('[Sweetlink] Design review failed:', errorMessage);

              ws.send(JSON.stringify({
                success: false,
                type: 'design-review-error',
                error: errorMessage,
                timestamp: Date.now()
              }));
            }
            return;
          }
        }

        // Handle save-outline request from browser
        if (command.type === 'save-outline') {
          console.log('[Sweetlink] Received save-outline command');
          const clientInfo = clients.get(ws);

          if (command.data && clientInfo?.type === 'browser') {
            try {
              const result = await handleSaveOutline(command.data as {
                outline: unknown[];
                markdown: string;
                url: string;
                title: string;
                timestamp: number;
              });
              console.log(`[Sweetlink] Outline saved to ${result.outlinePath}`);

              // Send confirmation back to browser
              ws.send(JSON.stringify({
                success: true,
                type: 'outline-saved',
                outlinePath: result.outlinePath,
                timestamp: Date.now()
              }));
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Unknown error';
              console.error('[Sweetlink] Outline save failed:', errorMessage);

              ws.send(JSON.stringify({
                success: false,
                type: 'outline-error',
                error: errorMessage,
                timestamp: Date.now()
              }));
            }
            return;
          }
        }

        // Handle save-schema request from browser
        if (command.type === 'save-schema') {
          console.log('[Sweetlink] Received save-schema command');
          const clientInfo = clients.get(ws);

          if (command.data && clientInfo?.type === 'browser') {
            try {
              const result = await handleSaveSchema(command.data as {
                schema: unknown;
                markdown: string;
                url: string;
                title: string;
                timestamp: number;
              });
              console.log(`[Sweetlink] Schema saved to ${result.schemaPath}`);

              // Send confirmation back to browser
              ws.send(JSON.stringify({
                success: true,
                type: 'schema-saved',
                schemaPath: result.schemaPath,
                timestamp: Date.now()
              }));
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Unknown error';
              console.error('[Sweetlink] Schema save failed:', errorMessage);

              ws.send(JSON.stringify({
                success: false,
                type: 'schema-error',
                error: errorMessage,
                timestamp: Date.now()
              }));
            }
            return;
          }
        }

        // ============================================================================
        // v1.4.0: New message handlers
        // ============================================================================

        // Handle request-screenshot from CLI/Agent
        if (command.type === 'request-screenshot') {
          const clientInfo = clients.get(ws);
          if (clientInfo?.type === 'cli') {
            const requestId = command.requestId || `req-${Date.now()}`;
            console.log(`[Sweetlink] Screenshot request ${requestId} from CLI`);

            // Find browser client
            const browserClients = Array.from(clients.entries())
              .filter(([_, info]) => info.type === 'browser')
              .map(([client, _]) => client);

            if (browserClients.length === 0) {
              ws.send(JSON.stringify({
                type: 'screenshot-response',
                requestId,
                success: false,
                error: 'No browser client connected',
                timestamp: Date.now()
              }));
              return;
            }

            // Set up timeout
            const timeout = setTimeout(() => {
              const pending = pendingScreenshotRequests.get(requestId);
              if (pending) {
                pendingScreenshotRequests.delete(requestId);
                pending.clientWs.send(JSON.stringify({
                  type: 'screenshot-response',
                  requestId,
                  success: false,
                  error: 'Screenshot request timed out',
                  timestamp: Date.now()
                }));
              }
            }, SCREENSHOT_REQUEST_TIMEOUT_MS);

            // Store pending request
            pendingScreenshotRequests.set(requestId, {
              requestId,
              clientWs: ws,
              timeout
            });

            // Forward to browser with requestId
            const browserWs = browserClients[0];
            browserWs.send(JSON.stringify({
              type: 'request-screenshot',
              requestId,
              selector: command.selector,
              format: command.format || 'jpeg',
              quality: command.quality || 0.7,
              scale: command.scale || 0.25,
              includeMetadata: command.includeMetadata !== false
            }));
            return;
          }
        }

        // Handle screenshot-response from browser
        if (command.type === 'screenshot-response') {
          const clientInfo = clients.get(ws);
          if (clientInfo?.type === 'browser' && command.requestId) {
            const pending = pendingScreenshotRequests.get(command.requestId);
            if (pending) {
              clearTimeout(pending.timeout);
              pendingScreenshotRequests.delete(command.requestId);
              // Forward response to CLI client
              if (pending.clientWs.readyState === WebSocket.OPEN) {
                pending.clientWs.send(message.toString());
              }
            }
            return;
          }
        }

        // Handle channel subscription (e.g., 'hmr-screenshots')
        if (command.type === 'subscribe') {
          const channel = command.channel;
          if (channel) {
            console.log(`[Sweetlink] Client subscribing to channel: ${channel}`);
            if (!channelSubscriptions.has(channel)) {
              channelSubscriptions.set(channel, []);
            }
            channelSubscriptions.get(channel)!.push({ channel, clientWs: ws });
            ws.send(JSON.stringify({
              type: 'subscribed',
              channel,
              timestamp: Date.now()
            }));
            return;
          }
        }

        // Handle channel unsubscription
        if (command.type === 'unsubscribe') {
          const channel = command.channel;
          if (channel && channelSubscriptions.has(channel)) {
            const subs = channelSubscriptions.get(channel)!;
            const idx = subs.findIndex(s => s.clientWs === ws);
            if (idx !== -1) {
              subs.splice(idx, 1);
              console.log(`[Sweetlink] Client unsubscribed from channel: ${channel}`);
            }
            ws.send(JSON.stringify({
              type: 'unsubscribed',
              channel,
              timestamp: Date.now()
            }));
            return;
          }
        }

        // Handle log subscription
        if (command.type === 'log-subscribe') {
          const subscriptionId = command.subscriptionId || `log-${Date.now()}`;
          console.log(`[Sweetlink] Log subscription created: ${subscriptionId}`);
          logSubscriptions.set(subscriptionId, {
            subscriptionId,
            clientWs: ws,
            filters: command.filters
          });
          ws.send(JSON.stringify({
            type: 'log-subscribed',
            subscriptionId,
            timestamp: Date.now()
          }));
          return;
        }

        // Handle log unsubscription
        if (command.type === 'log-unsubscribe') {
          if (command.subscriptionId && logSubscriptions.has(command.subscriptionId)) {
            logSubscriptions.delete(command.subscriptionId);
            console.log(`[Sweetlink] Log subscription removed: ${command.subscriptionId}`);
            ws.send(JSON.stringify({
              type: 'log-unsubscribed',
              subscriptionId: command.subscriptionId,
              timestamp: Date.now()
            }));
          }
          return;
        }

        // Handle HMR screenshot from browser
        if (command.type === 'hmr-screenshot') {
          const clientInfo = clients.get(ws);
          if (clientInfo?.type === 'browser' && command.data) {
            const hmrData = command.data as HmrScreenshotData;
            hmrSequenceNumber++;

            console.log(`[Sweetlink] HMR screenshot received (${hmrData.trigger})`);
            if (hmrData.changedFile) {
              console.log(`[Sweetlink] Changed file: ${hmrData.changedFile}`);
            }

            // Save screenshot and logs
            const result = await handleHmrScreenshot(hmrData);

            // Notify all subscribers on 'hmr-screenshots' channel
            const subscribers = channelSubscriptions.get('hmr-screenshots') || [];
            const notification = {
              type: 'hmr-screenshot-saved',
              screenshotPath: result.screenshotPath,
              logsPath: result.logsPath,
              trigger: hmrData.trigger,
              changedFile: hmrData.changedFile,
              timestamp: hmrData.timestamp,
              sequenceNumber: hmrSequenceNumber,
              logSummary: result.logSummary
            };

            for (const sub of subscribers) {
              if (sub.clientWs.readyState === WebSocket.OPEN) {
                sub.clientWs.send(JSON.stringify(notification));
              }
            }

            // Send confirmation back to browser
            ws.send(JSON.stringify({
              success: true,
              type: 'hmr-screenshot-saved',
              screenshotPath: result.screenshotPath,
              logsPath: result.logsPath,
              sequenceNumber: hmrSequenceNumber,
              timestamp: Date.now()
            }));
            return;
          }
        }

        // Handle log-event from browser (for streaming to subscribers)
        if (command.type === 'log-event') {
          const clientInfo = clients.get(ws);
          if (clientInfo?.type === 'browser' && command.data) {
            const log = command.data as ConsoleLog;
            // Forward to matching subscriptions
            for (const [_, sub] of logSubscriptions) {
              if (sub.clientWs.readyState !== WebSocket.OPEN) continue;

              // Apply filters
              if (sub.filters) {
                if (sub.filters.levels && !sub.filters.levels.includes(log.level)) continue;
                if (sub.filters.pattern) {
                  const regex = new RegExp(sub.filters.pattern, 'i');
                  if (!regex.test(log.message)) continue;
                }
                if (sub.filters.source && log.source !== sub.filters.source) continue;
              }

              sub.clientWs.send(JSON.stringify({
                type: 'log-event',
                subscriptionId: sub.subscriptionId,
                log,
                timestamp: Date.now()
              }));
            }
            return;
          }
        }

        // ============================================================================
        // End v1.4.0 handlers
        // ============================================================================

        const clientInfo = clients.get(ws);

        // If this is a CLI client sending a command, forward to browser
        if (clientInfo?.type === 'cli') {
          console.log(`[Sweetlink] Received command from CLI: ${command.type}`);

          // Find browser clients
          const browserClients = Array.from(clients.entries())
            .filter(([_, info]) => info.type === 'browser')
            .map(([client, _]) => client);

          if (browserClients.length === 0) {
            ws.send(JSON.stringify({
              success: false,
              error: 'No browser client connected. Is the dev server running with the page open?',
              timestamp: Date.now()
            } as SweetlinkResponse));
            return;
          }

          // Forward command to first browser client
          // Store reference to CLI client for response
          const browserWs = browserClients[0];
          (browserWs as any).__cliClient = ws;
          browserWs.send(message.toString());
        }
        // If this is a browser client sending a response, forward to CLI
        else if (clientInfo?.type === 'browser') {
          const cliWs = (ws as any).__cliClient;
          if (cliWs && cliWs.readyState === WebSocket.OPEN) {
            cliWs.send(message.toString());
            // Clear the reference
            delete (ws as any).__cliClient;
          }
        }

      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error('[Sweetlink] Error processing message:', errorMessage);

        ws.send(JSON.stringify({
          success: false,
          error: errorMessage,
          timestamp: Date.now()
        } as SweetlinkResponse));
      }
    });

    ws.on('close', () => {
      const clientInfo = clients.get(ws);
      console.log(`[Sweetlink] Client disconnected: ${clientInfo?.id} (${clientInfo?.type})`);
      cleanupClientSubscriptions(ws);
      clients.delete(ws);
    });

    ws.on('error', (error) => {
      console.error(`[Sweetlink] WebSocket error:`, error);
      cleanupClientSubscriptions(ws);
      clients.delete(ws);
    });
  });
}

async function handleSaveScreenshot(data: any): Promise<string> {
  const { screenshot, logs, url, timestamp, width, height } = data;

  // Create directory if it doesn't exist
  const dir = join(process.cwd(), SCREENSHOT_DIR);
  await fs.mkdir(dir, { recursive: true });

  // Generate filename with timestamp using shared utility
  const baseFilename = generateBaseFilename('screenshot', timestamp);

  // Save screenshot (remove data URL prefix, support both PNG and JPEG)
  const screenshotPath = join(dir, `${baseFilename}.jpg`);
  const base64Data = screenshot.replace(/^data:image\/(png|jpeg);base64,/, '');
  await fs.writeFile(screenshotPath, Buffer.from(base64Data, 'base64'));

  // Save console logs only if provided
  if (logs && Array.isArray(logs) && logs.length > 0) {
    // Save as human-readable text
    const logsPath = join(dir, `${baseFilename}-logs.txt`);
    const logLines = logs.map((log: any) => {
      const time = new Date(log.timestamp).toISOString();
      return `[${time}] ${log.level.toUpperCase()}: ${log.message}`;
    });

    const logsContent = [
      `Screenshot captured at: ${new Date(timestamp).toISOString()}`,
      `URL: ${url}`,
      `Dimensions: ${width}x${height}`,
      ``,
      `=== CONSOLE LOGS ===`,
      ``,
      ...logLines
    ].join('\n');

    await fs.writeFile(logsPath, logsContent, 'utf-8');
    console.log(`[Sweetlink] Console logs saved: ${logsPath}`);

    // Save as JSON for programmatic access
    const logsJsonPath = join(dir, `${baseFilename}-logs.json`);
    const logsJson = {
      meta: {
        capturedAt: new Date(timestamp).toISOString(),
        url,
        dimensions: { width, height }
      },
      logs: logs.map((log: any) => ({
        timestamp: new Date(log.timestamp).toISOString(),
        level: log.level,
        message: log.message
      }))
    };
    await fs.writeFile(logsJsonPath, JSON.stringify(logsJson, null, 2), 'utf-8');
    console.log(`[Sweetlink] Console logs JSON saved: ${logsJsonPath}`);
  }

  // Save a11y report if provided
  if (data.a11y && Array.isArray(data.a11y) && data.a11y.length > 0) {
    const a11yPath = join(dir, `${baseFilename}-a11y.json`);
    await fs.writeFile(a11yPath, JSON.stringify(data.a11y, null, 2), 'utf-8');
    console.log(`[Sweetlink] Accessibility report saved: ${a11yPath}`);
  } else if (data.a11y) {
    console.log('[Sweetlink] Accessibility check passed (no violations)');
  }

  return screenshotPath;
}

interface DesignReviewResult {
  screenshotPath: string;
  reviewPath: string;
}

/**
 * Handle design review screenshot: save screenshot, call Claude Vision API, save review markdown
 */
async function handleDesignReviewScreenshot(data: any): Promise<DesignReviewResult> {
  const { screenshot, logs, url, timestamp, width, height } = data;

  // Create directory if it doesn't exist
  const dir = join(process.cwd(), SCREENSHOT_DIR);
  await fs.mkdir(dir, { recursive: true });

  // Generate filename with timestamp using shared utility
  const baseFilename = generateBaseFilename('design-review', timestamp);

  // Save screenshot (PNG for better quality in design review)
  const screenshotPath = join(dir, `${baseFilename}.png`);
  const base64Data = screenshot.replace(/^data:image\/(png|jpeg);base64,/, '');
  await fs.writeFile(screenshotPath, Buffer.from(base64Data, 'base64'));
  console.log(`[Sweetlink] Design review screenshot saved: ${screenshotPath}`);

  // Call Claude Vision API for design review
  console.log('[Sweetlink] Calling Claude Vision API for design review...');

  const client = getAnthropicClient();

  // Determine media type from data URL
  const mediaType = screenshot.startsWith('data:image/png') ? 'image/png' : 'image/jpeg';

  const response = await client.messages.create({
    model: CLAUDE_MODEL,
    max_tokens: CLAUDE_MAX_TOKENS,
    messages: [
      {
        role: 'user',
        content: [
          {
            type: 'image',
            source: {
              type: 'base64',
              media_type: mediaType,
              data: base64Data,
            },
          },
          {
            type: 'text',
            text: DESIGN_REVIEW_PROMPT,
          },
        ],
      },
    ],
  });

  // Extract text content from response
  const reviewContent = response.content
    .filter((block): block is Anthropic.TextBlock => block.type === 'text')
    .map((block) => block.text)
    .join('\n\n');

  // Extract token usage and calculate cost
  const inputTokens = response.usage?.input_tokens ?? 0;
  const outputTokens = response.usage?.output_tokens ?? 0;
  const totalTokens = inputTokens + outputTokens;

  // Calculate costs using Claude pricing
  const inputCost = (inputTokens / 1_000_000) * CLAUDE_PRICING.input;
  const outputCost = (outputTokens / 1_000_000) * CLAUDE_PRICING.output;
  const totalCost = inputCost + outputCost;

  console.log(`[Sweetlink] Design review tokens: ${inputTokens} input, ${outputTokens} output, total: ${totalTokens}`);
  console.log(`[Sweetlink] Design review cost: $${totalCost.toFixed(4)}`);

  // Build the review markdown file
  const reviewMarkdown = `---
url: ${url}
timestamp: ${new Date(timestamp).toISOString()}
dimensions: ${width}x${height}
screenshot: ${baseFilename}.png
model: ${CLAUDE_MODEL}
tokens:
  input: ${inputTokens}
  output: ${outputTokens}
  total: ${totalTokens}
cost:
  input: $${inputCost.toFixed(4)}
  output: $${outputCost.toFixed(4)}
  total: $${totalCost.toFixed(4)}
---

${reviewContent}

---

## Console Logs Summary

${logs && logs.length > 0
    ? logs
        .filter((log: any) => log.level === 'error' || log.level === 'warn')
        .slice(0, 10)
        .map((log: any) => `- **${log.level.toUpperCase()}**: ${truncateMessage(log.message, MAX_LOG_MESSAGE_LENGTH)}`)
        .join('\n') || '_No errors or warnings in console_'
    : '_No console logs captured_'
}
`;

  // Save the review markdown
  const reviewPath = join(dir, `${baseFilename}.md`);
  await fs.writeFile(reviewPath, reviewMarkdown, 'utf-8');
  console.log(`[Sweetlink] Design review markdown saved: ${reviewPath}`);

  return { screenshotPath, reviewPath };
}

interface OutlineSaveResult {
  outlinePath: string;
}

/**
 * Handle document outline save: saves the outline as markdown to the screenshots folder
 */
async function handleSaveOutline(data: {
  outline: unknown[];
  markdown: string;
  url: string;
  title: string;
  timestamp: number;
}): Promise<OutlineSaveResult> {
  const { markdown, url, title, timestamp } = data;

  // Create directory if it doesn't exist
  const dir = join(process.cwd(), SCREENSHOT_DIR);
  await fs.mkdir(dir, { recursive: true });

  // Generate a slug from URL path or title and create filename with shared utility
  const slug = generateSlugFromUrl(url, title);
  const baseFilename = generateBaseFilename('outline', timestamp, slug);

  // Build the outline markdown file with frontmatter
  const outlineMarkdown = `---
title: ${title || 'Document Outline'}
url: ${url}
timestamp: ${new Date(timestamp).toISOString()}
---

# Document Outline

> Page: ${title || url}
> Generated: ${new Date(timestamp).toLocaleString()}

${markdown || '_No headings found in this document_'}
`;

  // Save the outline markdown
  const outlinePath = join(dir, `${baseFilename}.md`);
  await fs.writeFile(outlinePath, outlineMarkdown, 'utf-8');
  console.log(`[Sweetlink] Document outline saved: ${outlinePath}`);

  return { outlinePath };
}

interface SchemaSaveResult {
  schemaPath: string;
}

/**
 * Handle page schema save: saves structured data as markdown to the screenshots folder
 */
async function handleSaveSchema(data: {
  schema: unknown;
  markdown: string;
  url: string;
  title: string;
  timestamp: number;
}): Promise<SchemaSaveResult> {
  const { schema, markdown, url, title, timestamp } = data;

  // Create directory if it doesn't exist
  const dir = join(process.cwd(), SCREENSHOT_DIR);
  await fs.mkdir(dir, { recursive: true });

  // Generate a slug from URL path or title and create filename with shared utility
  const slug = generateSlugFromUrl(url, title);
  const baseFilename = generateBaseFilename('schema', timestamp, slug);

  // Build the schema markdown file with frontmatter
  const schemaMarkdown = `---
title: ${title || 'Page Schema'}
url: ${url}
timestamp: ${new Date(timestamp).toISOString()}
---

# Page Schema

> Page: ${title || url}
> Generated: ${new Date(timestamp).toLocaleString()}

${markdown || '_No structured data found on this page_'}

---

## Raw JSON

\`\`\`json
${JSON.stringify(schema, null, 2)}
\`\`\`
`;

  // Save the schema markdown
  const schemaPath = join(dir, `${baseFilename}.md`);
  await fs.writeFile(schemaPath, schemaMarkdown, 'utf-8');
  console.log(`[Sweetlink] Page schema saved: ${schemaPath}`);

  return { schemaPath };
}

/**
 * Handle HMR screenshot: save screenshot and logs, return paths and summary
 */
interface HmrScreenshotResult {
  screenshotPath: string;
  logsPath: string;
  logSummary: {
    totalLogs: number;
    errorCount: number;
    warningCount: number;
    hasNewErrors: boolean;
  };
}

async function handleHmrScreenshot(data: HmrScreenshotData): Promise<HmrScreenshotResult> {
  const { screenshot, url, timestamp, logs, trigger, changedFile, hmrMetadata } = data;

  // Create directory if it doesn't exist
  const dir = join(process.cwd(), HMR_SCREENSHOT_DIR);
  await fs.mkdir(dir, { recursive: true });

  // Generate filename with timestamp and trigger using shared utility
  const baseFilename = generateBaseFilename('hmr', timestamp, trigger);

  // Save screenshot
  const screenshotPath = join(dir, `${baseFilename}.jpg`);
  const base64Data = screenshot.replace(/^data:image\/(png|jpeg);base64,/, '');
  await fs.writeFile(screenshotPath, Buffer.from(base64Data, 'base64'));

  // Calculate log summary
  const errorCount = logs.errors.length;
  const warningCount = logs.warnings.length;
  const logSummary = {
    totalLogs: logs.all.length,
    errorCount,
    warningCount,
    hasNewErrors: errorCount > 0 // In a real implementation, we'd track previous error count
  };

  // Save logs as JSON
  const logsPath = join(dir, `${baseFilename}-logs.json`);
  const logsJson = {
    meta: {
      capturedAt: new Date(timestamp).toISOString(),
      url,
      trigger,
      changedFile,
      hmrMetadata
    },
    summary: logSummary,
    logs: {
      all: logs.all.map((log) => ({
        timestamp: new Date(log.timestamp).toISOString(),
        level: log.level,
        message: log.message,
        stack: log.stack,
        source: log.source
      })),
      errors: logs.errors.map((log) => ({
        timestamp: new Date(log.timestamp).toISOString(),
        level: log.level,
        message: log.message,
        stack: log.stack,
        source: log.source
      })),
      warnings: logs.warnings.map((log) => ({
        timestamp: new Date(log.timestamp).toISOString(),
        level: log.level,
        message: log.message,
        stack: log.stack,
        source: log.source
      }))
    }
  };
  await fs.writeFile(logsPath, JSON.stringify(logsJson, null, 2), 'utf-8');

  // Log summary to console
  const errorEmoji = errorCount > 0 ? '❌' : '✓';
  const warnEmoji = warningCount > 0 ? '⚠️' : '✓';
  console.log(`[Sweetlink] HMR screenshot saved: ${screenshotPath}`);
  console.log(`[Sweetlink] Logs: ${logs.all.length} total | ${warnEmoji} ${warningCount} warnings | ${errorEmoji} ${errorCount} errors`);

  // If there are errors, log them
  if (errorCount > 0) {
    console.log('[Sweetlink] Errors:');
    for (const error of logs.errors.slice(0, 3)) {
      console.log(`  └─ ${error.message.slice(0, 100)}`);
    }
    if (errorCount > 3) {
      console.log(`  └─ ... and ${errorCount - 3} more errors`);
    }
  }

  return { screenshotPath, logsPath, logSummary };
}

// Clean up subscriptions when client disconnects
function cleanupClientSubscriptions(ws: WebSocket) {
  // Remove from channel subscriptions
  for (const [_channel, subs] of channelSubscriptions) {
    const idx = subs.findIndex(s => s.clientWs === ws);
    if (idx !== -1) {
      subs.splice(idx, 1);
    }
  }

  // Remove log subscriptions
  for (const [id, sub] of logSubscriptions) {
    if (sub.clientWs === ws) {
      logSubscriptions.delete(id);
    }
  }

  // Clear pending screenshot requests
  for (const [id, pending] of pendingScreenshotRequests) {
    if (pending.clientWs === ws) {
      clearTimeout(pending.timeout);
      pendingScreenshotRequests.delete(id);
    }
  }
}

export function closeSweetlink() {
  if (wss) {
    console.log('[Sweetlink] Closing WebSocket server on port', activePort);
    clients.forEach((_, client) => client.close());
    clients.clear();
    wss.close();
    wss = null;
    activePort = null;
  }
}
